<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制 3D 粒子圣诞树</title>
    <style>
        /* 1. CSS 样式 */
        body { margin: 0; overflow: hidden; background-color: #0d0d0d; }
        canvas { display: block; }
        #webcam-container {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 200px; /* 调整为合适大小 */
            height: 150px;
            border: 2px solid #a80000;
            z-index: 10;
            overflow: hidden;
        }
        #webcam {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* 镜像翻转，使手势更直观 */
        }
        #status {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            color: #ffffff;
            font-family: sans-serif;
            font-size: 16px;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            z-index: 11;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.1/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466860/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
</head>
<body>
    <div id="webcam-container">
        <video id="webcam" autoplay playsinline></video>
    </div>
    <div id="status">手势状态: 等待中...</div>

    <script>
        // 2. JavaScript 逻辑 (Three.js & MediaPipe)

        /* --- Three.js 初始化 --- */
        let scene, camera, renderer;
        let particleSystem, photoMeshes = [];
        let state = 'closed'; // 'closed' (合拢), 'scattered' (分散)
        let particleCount = 10000;
        let particlesGeometry, particlesMaterial;
        let currentRotation = { x: 0, y: 0 };
        const ROTATION_SPEED = 0.005;

        // 模拟照片数据 (需要替换为实际图片)
        const photoUrls = [
            'https://via.placeholder.com/64x64/a80000/ffffff?text=Photo1',
            'https://via.placeholder.com/64x64/00a800/ffffff?text=Photo2',
            'https://via.placeholder.com/64x64/0000a8/ffffff?text=Photo3',
            // ... 更多图片
        ];
        const photoMeshesGroup = new THREE.Group();

        function initThree() {
            // 场景
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x0a0a0a, 10, 50); // 电影感雾效

            // 摄像头
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.z = 5;

            // 渲染器
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x0a0a0a); // 深色背景
            document.body.appendChild(renderer.domElement);

            // 光源：增强辉光与光晕
            const ambientLight = new THREE.AmbientLight(0x404040, 5); // 柔和环境光
            scene.add(ambientLight);
            const pointLight = new THREE.PointLight(0xffccaa, 500, 100); // 暖白点光源
            pointLight.position.set(5, 10, 5);
            pointLight.castShadow = true;
            scene.add(pointLight);

            // 辉光效果 (使用后处理如 UnrealBloomPass 可以达到更好效果，此处为简化)

            // 初始化粒子系统
            setupParticles();
            // 初始化照片云
            setupPhotoMeshes();

            window.addEventListener('resize', onWindowResize, false);
        }

        function setupParticles() {
            particlesGeometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const colorClosed = new THREE.Color(0x009900); // 哑光绿
            const colorScattered = new THREE.Color(0xffcc00); // 金属金
            const tempColor = new THREE.Color();

            // 生成初始位置 (圆锥/圣诞树形状)
            for (let i = 0; i < particleCount; i++) {
                const h = Math.random() * 4; // 高度 0 到 4
                const r = (1 - h / 4) * 2 * Math.random(); // 半径随高度递减
                const theta = Math.random() * Math.PI * 2;

                positions.push(r * Math.cos(theta), h - 1, r * Math.sin(theta));

                // 初始颜色设置为哑光绿
                tempColor.copy(colorClosed).lerp(new THREE.Color(0xff0000), Math.random() * 0.1); // 混合少量圣诞红
                colors.push(tempColor.r, tempColor.g, tempColor.b);
            }

            particlesGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particlesGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            particlesGeometry.setAttribute('initialPosition', new THREE.Float32BufferAttribute(positions.slice(), 3)); // 存储初始位置

            particlesMaterial = new THREE.PointsMaterial({
                size: 0.05,
                vertexColors: true,
                blending: THREE.AdditiveBlending, // 增加辉光感
                transparent: true,
                sizeAttenuation: true
            });

            particleSystem = new THREE.Points(particlesGeometry, particlesMaterial);
            scene.add(particleSystem);
        }

        // 照片云初始化 (简化，只显示基本的 Mesh)
        function setupPhotoMeshes() {
            const textureLoader = new THREE.TextureLoader();
            const boxGeometry = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            
            photoUrls.forEach((url, index) => {
                const texture = textureLoader.load(url);
                const material = new THREE.MeshBasicMaterial({ map: texture });
                const mesh = new THREE.Mesh(boxGeometry, material);
                
                // 初始位置 (树干附近)
                mesh.position.set((Math.random() - 0.5) * 0.5, -1, (Math.random() - 0.5) * 0.5);
                
                photoMeshes.push(mesh);
                photoMeshesGroup.add(mesh);
            });
            scene.add(photoMeshesGroup);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        /* --- 动画循环 --- */
        let targetStatePositions = null;
        let animationProgress = 0;
        const animationDuration = 60; // 动画帧数

        function animate() {
            requestAnimationFrame(animate);

            // 状态过渡动画
            if (animationProgress < 1) {
                animationProgress += 1 / animationDuration;
                updateParticlePositions(animationProgress);
                updatePhotoPositions(animationProgress);
            }

            // 旋转画面
            particleSystem.rotation.y += currentRotation.y;
            photoMeshesGroup.rotation.y += currentRotation.y;
            
            // 照片面向相机
            photoMeshes.forEach(mesh => {
                mesh.lookAt(camera.position);
            });

            renderer.render(scene, camera);
        }

        function updateParticlePositions(progress) {
            const positions = particlesGeometry.getAttribute('position');
            const initialPositions = particlesGeometry.getAttribute('initialPosition');
            const count = initialPositions.count;

            for (let i = 0; i < count; i++) {
                const initialX = initialPositions.getX(i);
                const initialY = initialPositions.getY(i);
                const initialZ = initialPositions.getZ(i);

                // 目标位置
                let targetX, targetY, targetZ;

                if (state === 'closed') {
                    // 合拢状态：回到圣诞树的初始位置
                    targetX = initialX;
                    targetY = initialY;
                    targetZ = initialZ;
                } else if (state === 'scattered') {
                    // 分散状态：随机扩散到空间中
                    if (!targetStatePositions) {
                         // 在第一次进入分散状态时计算目标随机位置
                         targetStatePositions = new THREE.Float32BufferAttribute(new Float32Array(count * 3), 3);
                         for (let j = 0; j < count; j++) {
                            // 随机分布在一个球体或立方体内
                            targetStatePositions.setXYZ(j, 
                                (Math.random() - 0.5) * 20, 
                                (Math.random() - 0.5) * 20, 
                                (Math.random() - 0.5) * 20
                            );
                         }
                    }
                    targetX = targetStatePositions.getX(i);
                    targetY = targetStatePositions.getY(i);
                    targetZ = targetStatePositions.getZ(i);
                }

                // 平滑插值 (Lerp)
                const currentX = positions.getX(i);
                const currentY = positions.getY(i);
                const currentZ = positions.getZ(i);

                const lerpX = currentX + (targetX - currentX) * progress;
                const lerpY = currentY + (targetY - currentY) * progress;
                const lerpZ = currentZ + (targetZ - currentZ) * progress;

                positions.setXYZ(i, lerpX, lerpY, lerpZ);
            }

            positions.needsUpdate = true;
        }

        // 照片位置更新逻辑 (简化，跟随粒子系统的状态变化)
        function updatePhotoPositions(progress) {
            photoMeshes.forEach(mesh => {
                let targetPos = new THREE.Vector3();
                if (state === 'closed') {
                    // 合拢状态：回到树干附近
                    targetPos.set((Math.random() - 0.5) * 0.5, -1, (Math.random() - 0.5) * 0.5);
                } else if (state === 'scattered') {
                    // 分散状态：环绕在摄像机周围
                    targetPos.set(
                        (Math.random() - 0.5) * 10, 
                        (Math.random() - 0.5) * 10, 
                        (Math.random() - 0.5) * 10
                    );
                }

                // 平滑插值
                mesh.position.lerp(targetPos, progress);
            });
        }
        
        // 切换状态函数
        function transitionState(newState) {
            if (state !== newState) {
                state = newState;
                animationProgress = 0; // 重置动画进度
                document.getElementById('status').innerText = `手势状态: ${newState === 'closed' ? '合拢' : '分散'}`;

                // 分散状态需要计算随机目标位置，合拢状态则不需要
                if (newState === 'closed') {
                    targetStatePositions = null; // 清除分散目标位置
                }
            }
        }


        /* --- MediaPipe Hands 逻辑 --- */
        const videoElement = document.getElementById('webcam');
        const statusElement = document.getElementById('status');
        let currentHandLandmarks = null;
        let lastHandLandmarks = null;
        let lastZoomDistance = 0;

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675466860/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // 摄像头设置
        const cameraMP = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });
        cameraMP.start();

        function onResults(results) {
            if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                currentHandLandmarks = null;
                // 停止所有动画控制，回到默认状态
                currentRotation.y = 0; 
                return;
            }

            currentHandLandmarks = results.multiHandLandmarks[0]; // 只处理第一只手
            
            // 1. 识别手势并触发状态切换
            const gesture = recognizeGesture(currentHandLandmarks);
            
            if (gesture === 'fist') {
                transitionState('closed'); // 握拳 = 合拢
            } else if (gesture === 'open_palm') {
                transitionState('scattered'); // 五指张开 = 分散
            } else if (gesture === 'hand_rotate') {
                // 2. 旋转画面 (基于手掌中心X坐标变化)
                if (lastHandLandmarks) {
                    const currentX = currentHandLandmarks[0].x;
                    const lastX = lastHandLandmarks[0].x;
                    const deltaX = currentX - lastX;
                    currentRotation.y = deltaX * -3 * ROTATION_SPEED; // 根据移动方向和速度设置旋转
                }
            } else if (gesture === 'grab_zoom') {
                // 3. 抓取 = 放大照片 (简化：放大粒子/照片云，实际应针对特定照片)
                const distance = getZoomDistance(currentHandLandmarks);
                if (lastZoomDistance > 0) {
                    const deltaDistance = distance - lastZoomDistance;
                    camera.position.z -= deltaDistance * 10; // 调整相机Z轴模拟放大
                    camera.position.z = THREE.MathUtils.clamp(camera.position.z, 2, 10); // 限制缩放范围
                }
                lastZoomDistance = distance;
            } else {
                 currentRotation.y *= 0.9; // 缓慢停止旋转
                 lastZoomDistance = 0; // 重置缩放距离
            }

            lastHandLandmarks = currentHandLandmarks;
        }
        
        // --- 核心手势识别函数 ---

        // 辅助函数：计算两点之间的距离 (基于MediaPipe规范化的坐标)
        function dist(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) + Math.pow(p1.z - p2.z, 2));
        }

        function recognizeGesture(landmarks) {
            // 关键点索引：0:手腕, 4:拇指尖, 8:食指尖, 12:中指尖, 16:无名指尖, 20:小指尖
            const thumbTip = landmarks[4];
            const indexTip = landmarks[8];
            const middleTip = landmarks[12];
            const ringTip = landmarks[16];
            const pinkyTip = landmarks[20];
            const wrist = landmarks[0];

            // 1. 握拳 (Fist)
            // 所有指尖都靠近掌心 (landmarks[5], [9], [13], [17] 附近，简化为指尖靠近手腕)
            const indexDist = dist(indexTip, landmarks[5]); // 食指尖到食指根部
            const middleDist = dist(middleTip, landmarks[9]);
            
            // 设定一个阈值来判断是否弯曲
            const FIST_THRESHOLD = 0.15; 
            const isFist = indexDist < FIST_THRESHOLD && middleDist < FIST_THRESHOLD &&
                           dist(ringTip, landmarks[13]) < FIST_THRESHOLD && 
                           dist(pinkyTip, landmarks[17]) < FIST_THRESHOLD;

            if (isFist) {
                return 'fist';
            }

            // 2. 五指张开 (Open Palm)
            // 所有指尖都远离掌心，且彼此距离较大
            const OPEN_THRESHOLD = 0.3; // 扩大阈值，避免误判为旋转/抓取
            const isOpen = indexDist > OPEN_THRESHOLD && middleDist > OPEN_THRESHOLD &&
                           dist(ringTip, landmarks[13]) > OPEN_THRESHOLD && 
                           dist(pinkyTip, landmarks[17]) > OPEN_THRESHOLD;
                           
            // 额外的判断：检查拇指和食指是否分开
            const thumbToIndexDist = dist(thumbTip, indexTip);
            const SEPARATE_THRESHOLD = 0.2; 
                           
            if (isOpen && thumbToIndexDist > SEPARATE_THRESHOLD) {
                return 'open_palm';
            }

            // 3. 抓取/放大照片 (Grab/Zoom)
            // 拇指和食指靠近（捏合/抓取动作），其他手指可能弯曲或放松
            const GRAB_THRESHOLD = 0.05;
            if (thumbToIndexDist < GRAB_THRESHOLD) {
                return 'grab_zoom';
            }
            
            // 4. 手旋转 (Hand Rotate)
            // 默认判断为旋转，只要手在视野内且没有处于明确的'握拳'或'张开'状态
            // 旋转动作依赖于手的连续运动，在 onResults 中判断
            if (currentHandLandmarks) {
                return 'hand_rotate';
            }
            
            return 'none';
        }
        
        // 计算缩放距离 (拇指尖和食指尖的距离)
        function getZoomDistance(landmarks) {
            return dist(landmarks[4], landmarks[8]);
        }


        // 启动应用
        initThree();
        animate();
    </script>
</body>
</html>